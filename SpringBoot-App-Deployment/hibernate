import org.hibernate.transform.ResultTransformer;
// ... other imports

public class OperatorDetailInfoResultTransformer implements ResultTransformer {
    
    private Map<String, OperatorDetailInfo> operatorDetailInfoMap = new HashMap<>();

    @Override
    public Object transformTuple(Object[] tuple, String[] aliases) {
        OperatorDetailInfo operatorDetailInfo = operatorDetailInfoMap.computeIfAbsent(
                (String) tuple[0],  // Assuming the first column is the ID 
                id -> new OperatorDetailInfo(id, (String) tuple[1], /* ... other fields... */) 
        ); 

        if (tuple[7] != null) { // Assuming the 7th column is the 'version' field 
           operatorDetailInfo.getVersions().add(
                   new VersionInfoDTO((String) tuple[7], (String) tuple[8], (String) tuple[9])
           );
        }

        return operatorDetailInfo; 
    }

    @Override
    public List transformList(List collection) {
        return new ArrayList<>(operatorDetailInfoMap.values());
    }
}


import java.util.concurrent.ForkJoinPool;
import java.util.stream.Collectors;

// ...

private List<OperatorInfoDTO> convertToOperatorInfoDTOs(List<Object[]> results) {
    // Your conversion logic here
    // ...

    ForkJoinPool forkJoinPool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());

    return forkJoinPool.submit(() ->
            results.parallelStream().map(tuple -> {
                OperatorInfoDTO operatorInfoDTO = new OperatorInfoDTO();
                operatorInfoDTO.setId(tuple[0] != null ? tuple[0].toString() : null);
                operatorInfoDTO.setStatusIndicator(tuple[1] != null ? tuple[1].toString() : null);
                operatorInfoDTO.setProviderName(tuple[2] != null ? tuple[2].toString() : null);
                operatorInfoDTO.setCid(tuple[3] != null ? tuple[3].toString() : null);
                operatorInfoDTO.setIca(tuple[4] != null ? tuple[4].toString() : null);

                // Conditionally set StatusCodeDescription only if not null
                if (tuple[5] != null) {
                    operatorInfoDTO.setStatusCodeDescription(tuple[5].toString());
                }

                // Conditionally set other fields only if not null
                if (tuple[6] != null) {
                    // Assuming versions is a List<VersionInfoDTO> already populated
                    operatorInfoDTO.setVersions((List<VersionInfoDTO>) tuple[6]);
                }

                // Add conditions for other fields here

                return operatorInfoDTO;
            }).collect(Collectors.toList())
    ).join();
}



@Query("SELECT od.id, od.statusIndicator, od.providerName, od.cid, od.ica, od.countryCode, od.statusCodeDescription, ver.version, ver.messageCategory, ver.statusIndicator " +
       "FROM OperatorDetail od LEFT JOIN od.versions ver")
Page<OperatorDetailInfo> findAllOperatorDetailInfo(Pageable pageable, ResultTransformer transformer); 


import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class OperatorService {

    private final OperatorDetailRepository operatorDetailRepository;

    public OperatorService(OperatorDetailRepository operatorDetailRepository) {
        this.operatorDetailRepository = operatorDetailRepository;
    }

    public OperatorInfo getAllOperatorDetails(Pageable pageable) {
        Page<Object[]> results = operatorDetailRepository.findAllOperatorDetailInfo(pageable);
        List<OperatorInfoDTO> operatorInfoDTOList = convertToOperatorInfoDTOs(results.getContent());

        OperatorInfo operatorInfo = new OperatorInfo();
        operatorInfo.setCount(operatorInfoDTOList.size());
        operatorInfo.setOffset(pageable.getPageNumber());
        operatorInfo.setLimit(pageable.getPageSize());
        operatorInfo.setOps(operatorInfoDTOList);

        return operatorInfo;
    }

    private List<OperatorInfoDTO> convertToOperatorInfoDTOs(List<Object[]> results) {
        // Your conversion logic here
        // ...

        // Assuming each row contains an OperatorInfoDTO and versions are already populated
        List<OperatorInfoDTO> operatorInfoDTOList = new ArrayList<>();
        for (Object[] tuple : results) {
            OperatorInfoDTO operatorInfoDTO = new OperatorInfoDTO();
            operatorInfoDTO.setId((String) tuple[0]);
            operatorInfoDTO.setStatusIndicator((String) tuple[1]);
            operatorInfoDTO.setProviderName((String) tuple[2]);
            operatorInfoDTO.setCid((String) tuple[3]);
            operatorInfoDTO.setIca((String) tuple[4]);
            operatorInfoDTO.setStatusCodeDescription((String) tuple[5]);
            // Assuming versions is a List<VersionInfoDTO> already populated
            operatorInfoDTO.setVersions((List<VersionInfoDTO>) tuple[6]);

            operatorInfoDTOList.add(operatorInfoDTO);
        }

        return operatorInfoDTOList;
    }
}

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface OperatorDetailRepository extends JpaRepository<OperatorDetail, String> {

    @Query("SELECT od.id, od.statusIndicator, od.providerName, od.cid, od.ica, od.countryCode, od.statusCodeDescription, ver " +
           "FROM OperatorDetail od LEFT JOIN FETCH od.versions ver")
    Page<Object[]> findAllOperatorDetailInfo(Pageable pageable);
}
