

Gzip Compression:

Include the spring-boot-starter-tomcat dependency in your pom.xml.

Add the following configuration in your application.yml:

yaml

server:
  compression:
    enabled: true
    mime-types: application/json
    min-response-size: 10KB

Content-Encoding (Compression)
For compression (Content-Encoding like gzip or deflate), Spring Boot can automatically compress responses if certain conditions are met. This behavior is controlled by server properties and the client's Accept-Encoding header:

Compression Enabled: Enable response compression explicitly in application.yml file for Spring Boot to compress responses. This is done by setting properties server.compression.enabled=true and specifying the mime types to be compressed via server.compression.mime-types=application/json
Client Accept-Encoding Header: The client must indicate support for compression through the Accept-Encoding header, e.g. Accept-Encoding: gzip, deflate

 WebClient webClient = WebClient.builder()
                .baseUrl("APIURL")
                .defaultHeader("Accept-Encoding", "gzip, deflate")



import org.springframework.web.reactive.function.client.WebClient;
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;
import org.springframework.http.MediaType;

public class GzipCpuUsageTest {

    private WebClient webClient;

    public GzipCpuUsageTest() {
        this.webClient = WebClient.builder()
                .baseUrl("http://provider-service-endpoint")
                .build();
    }

    public void performTest(boolean useGzip) {
        WebClient.RequestHeadersSpec<?> requestSpec = this.webClient.get().uri("/large-response");

        if (useGzip) {
            requestSpec.header("Accept-Encoding", "gzip");
        } else {
            requestSpec.accept(MediaType.APPLICATION_JSON);
        }

        for (int i = 0; i < 10000; i++) { // Simulate 10,000 requests
            requestSpec.retrieve()
                    .bodyToMono(String.class)
                    .block();
        }
    }

    public double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
        return osBean.getSystemLoadAverage();
    }

    public static void main(String[] args) {
        GzipCpuUsageTest test = new GzipCpuUsageTest();

        // Preliminary test phase without GZIP
        System.out.println("Starting preliminary test without GZIP...");
        double cpuBeforeJson = test.getCpuUsage();
        test.performTest(false);
        double cpuAfterJson = test.getCpuUsage();
        System.out.println("CPU Usage Before JSON Test: " + cpuBeforeJson);
        System.out.println("CPU Usage After JSON Test: " + cpuAfterJson);

        // Main test phase with GZIP
        System.out.println("Starting main test with GZIP...");
        double cpuBeforeGzip = test.getCpuUsage();
        test.performTest(true);
        double cpuAfterGzip = test.getCpuUsage();
        System.out.println("CPU Usage Before GZIP Test: " + cpuBeforeGzip);
        System.out.println("CPU Usage After GZIP Test: " + cpuAfterGzip);
    }
}


@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient(timeout = "36000") // Increased timeout for real network calls
public class GzipHeaderIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    public void testResponseWithGzipEncodingWhenRequested() {
        webTestClient.get().uri("http://provider-service-url/api/data") // Full URL if necessary
            .header("Accept-Encoding", "gzip")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().valueEquals("Content-Encoding", "gzip")
            .expectBody()
            .consumeWith(response -> {
                assertThat(response.getResponseBody()).isNotNull();
            });
    }

    @Test
    public void testResponseWithoutGzipEncodingWhenNotRequested() {
        webTestClient.get().uri("http://provider-service-url/api/data")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().doesNotExist("Content-Encoding")
            .expectBody(String.class)
            .consumeWith(response -> {
                assertThat(response.getResponseBody()).isNotNull();
            });
    }
}

<dependency>
    <groupId>org.assertj</groupId>
    <artifactId>assertj-core</artifactId>
    <version>3.23.1</version>
    <scope>test</scope>
</dependency>
