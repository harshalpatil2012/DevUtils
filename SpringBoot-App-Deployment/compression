

Gzip Compression:

Include the spring-boot-starter-tomcat dependency in your pom.xml.

Add the following configuration in your application.yml:

yaml

server:
  compression:
    enabled: true
    mime-types: application/json
    min-response-size: 10KB

Content-Encoding (Compression)
For compression (Content-Encoding like gzip or deflate), Spring Boot can automatically compress responses if certain conditions are met. This behavior is controlled by server properties and the client's Accept-Encoding header:

Compression Enabled: Enable response compression explicitly in application.yml file for Spring Boot to compress responses. This is done by setting properties server.compression.enabled=true and specifying the mime types to be compressed via server.compression.mime-types=application/json
Client Accept-Encoding Header: The client must indicate support for compression through the Accept-Encoding header, e.g. Accept-Encoding: gzip, deflate

 WebClient webClient = WebClient.builder()
                .baseUrl("APIURL")
                .defaultHeader("Accept-Encoding", "gzip, deflate")

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.core.read.ListAppender;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.web.reactive.function.client.*;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;

import static org.mockito.Mockito.*;
import static org.mockito.ArgumentMatchers.any;
import static org.assertj.core.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
public class WebClientConfigTests {

    @Mock
    private WebClient.Builder builder;

    @Mock
    private HttpClient httpClient;

    @InjectMocks
    private WebClientConfig webClientConfig;

    private ListAppender<ch.qos.logback.classic.spi.ILoggingEvent> listAppender;

    @BeforeEach
    void setUp() {
        // Initialize and configure ListAppender
        Logger logger = (Logger) LoggerFactory.getLogger(WebClientConfig.class);
        listAppender = new ListAppender<>();
        listAppender.start();
        logger.addAppender(listAppender);

        when(builder.filter(any(ExchangeFilterFunction.class))).thenReturn(builder);
        when(builder.clientConnector(any())).thenReturn(builder);
        when(builder.build()).thenReturn(WebClient.builder().build());
    }

    @Test
    void testWebClientIsProperlyConfigured() {
        WebClient webClient = webClientConfig.webClient();
        assertNotNull(webClient);
        verify(httpClient).compress(true);  // assuming default is true for compressionEnabled
        verify(builder).clientConnector(any());
        verify(builder, times(2)).filter(any());
    }

    @Test
    void testLogWebClientRequest() {
        ExchangeFilterFunction requestLogger = webClientConfig.logWebClientRequest();

        ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create("https://api.example.com/data"))
                                             .header("Authorization", "Bearer abc123")
                                             .build();

        requestLogger.filter(request, this::mockExchange)
                     .block();

        // Assert on the captured logs
        assertThat(listAppender.list)
            .extracting("formattedMessage")
            .contains("Calling Provider API GET https://api.example.com/data",
                      "Request Headers Authorization=Bearer abc123");
    }

    @Test
    void testLogWebClientResponseDetails() {
        ExchangeFilterFunction responseLogger = webClientConfig.logWebClientResponseDetails();

        ClientResponse response = ClientResponse.create(HttpStatus.OK)
                                                .header("Content-Type", "application/json")
                                                .body(Mono.just("response body"))
                                                .build();

        responseLogger.filter(response, this::mockExchange)
                      .block();

        // Assert on the captured logs
        assertThat(listAppender.list)
            .extracting("formattedMessage")
            .contains("Provider API response size: 1.000 KB",
                      "Provider API response Header: Content-Type=application/json");
    }

    private Mono<ClientResponse> mockExchange(ClientRequest request) {
        return Mono.just(ClientResponse.create(HttpStatus.OK).build());
    }
}




import org.springframework.web.reactive.function.client.WebClient;
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;
import org.springframework.http.MediaType;

public class GzipCpuUsageTest {

    private WebClient webClient;

    public GzipCpuUsageTest() {
        this.webClient = WebClient.builder()
                .baseUrl("http://provider-service-endpoint")
                .build();
    }

    public void performTest(boolean useGzip) {
        WebClient.RequestHeadersSpec<?> requestSpec = this.webClient.get().uri("/large-response");

        if (useGzip) {
            requestSpec.header("Accept-Encoding", "gzip");
        } else {
            requestSpec.accept(MediaType.APPLICATION_JSON);
        }

        for (int i = 0; i < 10000; i++) { // Simulate 10,000 requests
            requestSpec.retrieve()
                    .bodyToMono(String.class)
                    .block();
        }
    }

    public double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
        return osBean.getSystemLoadAverage();
    }

    public static void main(String[] args) {
        GzipCpuUsageTest test = new GzipCpuUsageTest();

        // Preliminary test phase without GZIP
        System.out.println("Starting preliminary test without GZIP...");
        double cpuBeforeJson = test.getCpuUsage();
        test.performTest(false);
        double cpuAfterJson = test.getCpuUsage();
        System.out.println("CPU Usage Before JSON Test: " + cpuBeforeJson);
        System.out.println("CPU Usage After JSON Test: " + cpuAfterJson);

        // Main test phase with GZIP
        System.out.println("Starting main test with GZIP...");
        double cpuBeforeGzip = test.getCpuUsage();
        test.performTest(true);
        double cpuAfterGzip = test.getCpuUsage();
        System.out.println("CPU Usage Before GZIP Test: " + cpuBeforeGzip);
        System.out.println("CPU Usage After GZIP Test: " + cpuAfterGzip);
    }
}


@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient(timeout = "36000") // Increased timeout for real network calls
public class GzipHeaderIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    public void testResponseWithGzipEncodingWhenRequested() {
        webTestClient.get().uri("http://provider-service-url/api/data") // Full URL if necessary
            .header("Accept-Encoding", "gzip")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().valueEquals("Content-Encoding", "gzip")
            .expectBody()
            .consumeWith(response -> {
                assertThat(response.getResponseBody()).isNotNull();
            });
    }

    @Test
    public void testResponseWithoutGzipEncodingWhenNotRequested() {
        webTestClient.get().uri("http://provider-service-url/api/data")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().doesNotExist("Content-Encoding")
            .expectBody(String.class)
            .consumeWith(response -> {
                assertThat(response.getResponseBody()).isNotNull();
            });
    }
}

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;
import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient(timeout = "36000") // Increased timeout for real network calls
public class GzipHeaderIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    public void testResponseWithGzipEncodingWhenRequested() {
        webTestClient.get().uri("http://provider-service-url/api/data") // Full URL if necessary
            .header("Accept-Encoding", "gzip")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().valueEquals("Content-Encoding", "gzip")
            .expectBody()
            .consumeWith(response -> {
                assertNotNull(response.getResponseBody(), "Response body should not be null");
            });
    }

    @Test
    public void testResponseWithoutGzipEncodingWhenNotRequested() {
        webTestClient.get().uri("http://provider-service-url/api/data")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().doesNotExist("Content-Encoding")
            .expectBody(String.class)
            .consumeWith(response -> {
                assertNotNull(response.getResponseBody(), "Response body should not be null");
            });
    }
}

https://github.com/spring-projects/spring-boot/issues/39040
https://github.com/spring-projects/spring-boot/issues/19942

