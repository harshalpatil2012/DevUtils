To create a generic interceptor to log REST API call details, including performance or execution time, you can use Spring's ClientHttpRequestInterceptor interface. Here's a sample interceptor that you can use to log API call details:



import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpRequest;
import org.springframework.http.HttpResponse;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;
import java.io.IOException;

public class RestApiLoggingInterceptor implements ClientHttpRequestInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(RestApiLoggingInterceptor.class);

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        long startTime = System.currentTimeMillis();
        ClientHttpResponse response = null;
        try {
            // Log the request details
            logRequest(request, body);

            // Execute the request
            response = execution.execute(request, body);

            // Log the response details
            logResponse(response);

            return response;
        } finally {
            if (response != null) {
                long endTime = System.currentTimeMillis();
                long executionTime = endTime - startTime;

                // Log the execution time
                logger.info("Request execution time: {} ms", executionTime);
            }
        }
    }

    private void logRequest(HttpRequest request, byte[] body) {
        logger.info("Request method: {}", request.getMethod());
        logger.info("Request URI: {}", request.getURI());
        logger.info("Request headers: {}", request.getHeaders());
        logger.info("Request body: {}", new String(body));
    }

    private void logResponse(ClientHttpResponse response) throws IOException {
        logger.info("Response status code: {}", response.getRawStatusCode());
        logger.info("Response status text: {}", response.getStatusText());
        logger.info("Response headers: {}", response.getHeaders());
        // If you want to log the response body, you can read it here, but be cautious with large responses
        // logger.info("Response body: {}", StreamUtils.copyToString(response.getBody(), StandardCharsets.UTF_8));
    }
}


This interceptor logs the request and response details, including method, URI, headers, and body. It also calculates and logs the execution time in milliseconds. You can configure the log level and appender in your logging framework (e.g., Logback or Log4j) to specify where the log messages should be written (e.g., to a file, console, etc.).

### 4. Integrate with RestTemplate
To use this interceptor with RestTemplate or WebClient, you can add it to the respective HTTP clients like this:

For RestTemplate:


RestTemplate restTemplate = new RestTemplate();
restTemplate.setInterceptors(Collections.singletonList(new RestApiLoggingInterceptor()));


For WebClient:

java
Copy code
WebClient.Builder webClientBuilder = WebClient.builder();
webClientBuilder.filter(new ExchangeFilterFunction() {
    @Override
    public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {
        return next.exchange(request)
                .doOnNext(clientResponse -> {
                    try {
                        new RestApiLoggingInterceptor().logResponse(clientResponse);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                });
    }
});


Make sure to customize the interceptor as needed, including handling and formatting of request and response data according to your specific requirements.

import java.util.HashMap;
import java.util.Map;


public class ThreadLocalContext {
    private static ThreadLocal<Map<String, String>> context = ThreadLocal.withInitial(HashMap::new);

    public static void setContextValue(String key, String value) {
        context.get().put(key, value);
    }

    public static String getContextValue(String key) {
        return context.get().get(key);
    }

    public static void clearContextValue(String key) {
        context.get().remove(key);
    }

    public static void clearAllContextValues() {
        context.get().clear();
    }
}

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoggingContextInterceptor());
    }
}

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class LoggingContextInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {       

        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        // Clear context values after the controller method completes
        ThreadLocalContext.clearAllContextValues;
    }
}


To make the above code more efficient, you can optimize the iteration over request headers and reduce unnecessary string concatenation. Here's an improved version of the RequestResponseLoggingFilter:

java

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.Enumeration;

@Component
@Order(1)
public class RequestResponseLoggingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // Wrap the request and response to capture the payloads
        ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper((HttpServletRequest) request);
        ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper((HttpServletResponse) response);

        // Log request information
        logRequest(requestWrapper);

        // Continue with the filter chain
        chain.doFilter(requestWrapper, responseWrapper);

        // Log response information
        logResponse(responseWrapper);

        // Forward the response to the original response
        responseWrapper.copyBodyToResponse();
    }

    private void logRequest(ContentCachingRequestWrapper request) {
        System.out.println("Request received: ");
        System.out.println("URI: " + request.getRequestURI());
        System.out.println("Method: " + request.getMethod());

        // Log request headers
        Enumeration<String> requestHeaders = request.getHeaderNames();
        while (requestHeaders.hasMoreElements()) {
            String headerName = requestHeaders.nextElement();
            Enumeration<String> headerValues = request.getHeaders(headerName);
            StringBuilder headerValueBuilder = new StringBuilder();
            while (headerValues.hasMoreElements()) {
                headerValueBuilder.append(headerValues.nextElement()).append(", ");
            }
            String headerValue = headerValueBuilder.toString();
            headerValue = headerValue.isEmpty() ? "" : headerValue.substring(0, headerValue.length() - 2);
            System.out.println(headerName + ": " + headerValue);
        }

        // Log request payload (body)
        byte[] requestBody = request.getContentAsByteArray();
        if (requestBody.length > 0) {
            System.out.println("Request Body: " + new String(requestBody));
        }
    }

    private void logResponse(ContentCachingResponseWrapper response) {
        System.out.println("Response sent with status: " + response.getStatus());

        // Log response headers
        response.getHeaderNames().forEach(headerName -> {
            String headerValue = String.join(", ", response.getHeaders(headerName));
            System.out.println(headerName + ": " + headerValue);
        });

        // Log response payload (body)
        byte[] responseBody = response.getContentAsByteArray();
        if (responseBody.length > 0) {
            System.out.println("Response Body: " + new String(responseBody));
        }
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization code (if needed)
    }

    @Override
    public void destroy() {
        // Cleanup code (if needed)
    }
}


import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import java.io.IOException;

@Component
@Order(1) // Set a low order value to run this filter before other filters
public class LoggingContextFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization code (if needed)
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        try {
            // Set context values here using ThreadLocal or any other method
            String sessionId = "12345";
            String appenderName = "myAppender";
            String customerNumber = "123";
            String customerType = "VIP";

            // Set context values in ThreadLocalContext
            ThreadLocalContext.setContextValue("sessionId", sessionId);
            ThreadLocalContext.setContextValue("appenderName", appenderName);
            ThreadLocalContext.setContextValue("customerNumber", customerNumber);
            ThreadLocalContext.setContextValue("customerType", customerType);

            // Continue the filter chain
            chain.doFilter(request, response);
        } finally {
            // Clear context values after the filter chain completes
            ThreadLocalContext.clearContextValue("sessionId");
            ThreadLocalContext.clearContextValue("appenderName");
            ThreadLocalContext.clearContextValue("customerNumber");
            ThreadLocalContext.clearContextValue("customerType");
        }
    }

    @Override
    public void destroy() {
        // Cleanup code (if needed)
    }
}

